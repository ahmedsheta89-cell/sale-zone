name: Deploy Firestore Rules

on:
  workflow_dispatch:
    inputs:
      target_sha:
        description: "Commit SHA to deploy Firestore rules from"
        required: true
        type: string
      reason:
        description: "Why this rules deployment is requested"
        required: true
        type: string

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-firestore-rules
  cancel-in-progress: false

jobs:
  deploy-firestore-rules:
    name: deploy-firestore-rules
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Validate required secrets
        run: |
          set -euo pipefail
          missing=0
          if [[ -z "${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}" ]]; then
            echo "::error::Missing secret: GCP_WORKLOAD_IDENTITY_PROVIDER"
            missing=1
          fi
          if [[ "$missing" -ne 0 ]]; then
            exit 1
          fi

      - name: Normalize identity secrets
        id: identity
        run: |
          set -euo pipefail

          provider_raw="${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          service_account_raw="${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}"

          provider="$(printf '%s' "$provider_raw" | tr -d '[:space:]')"
          service_account="$(printf '%s' "$service_account_raw" | tr -d '[:space:]')"

          if [[ -z "$provider" || "$provider" != projects/*/locations/global/workloadIdentityPools/*/providers/* ]]; then
            echo "::error::Invalid GCP_WORKLOAD_IDENTITY_PROVIDER format."
            echo "::error::Expected: projects/<number>/locations/global/workloadIdentityPools/<pool>/providers/<provider>"
            exit 1
          fi

          has_service_account=false
          if [[ -n "$service_account" ]]; then
            has_service_account=true
          fi

          if [[ "$has_service_account" == "true" && ! "$service_account" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.iam\.gserviceaccount\.com$ ]]; then
            echo "::error::Invalid GCP_SERVICE_ACCOUNT_EMAIL format."
            echo "::error::Expected: <name>@<project>.iam.gserviceaccount.com"
            exit 1
          fi

          echo "::add-mask::$provider"
          if [[ "$has_service_account" == "true" ]]; then
            echo "::add-mask::$service_account"
          fi

          echo "provider=$provider" >> "$GITHUB_OUTPUT"
          echo "service_account=$service_account" >> "$GITHUB_OUTPUT"
          echo "has_service_account=$has_service_account" >> "$GITHUB_OUTPUT"

      - name: Resolve project id
        id: project
        run: |
          set -euo pipefail
          raw="${{ secrets.FIREBASE_PROJECT_ID }}"
          project_id="$(printf '%s' "${raw:-sale-zone-601f0}" | tr -d '[:space:]')"
          if [[ -z "$project_id" || ! "$project_id" =~ ^[a-z0-9-]+$ ]]; then
            echo "::error::Invalid FIREBASE_PROJECT_ID: '$project_id'"
            exit 1
          fi
          echo "project_id=$project_id" >> "$GITHUB_OUTPUT"

      - name: Checkout target SHA
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_sha }}
          fetch-depth: 1

      - name: Verify checkout SHA matches target
        id: verify_sha
        run: |
          set -euo pipefail
          actual_sha="$(git rev-parse HEAD)"
          target_sha="${{ github.event.inputs.target_sha }}"
          if [[ "$actual_sha" != "$target_sha" ]]; then
            echo "::error::Checkout SHA mismatch (actual=$actual_sha, target=$target_sha)"
            exit 1
          fi
          echo "actual_sha=$actual_sha" >> "$GITHUB_OUTPUT"

      - name: Validate firestore.rules exists
        run: |
          set -euo pipefail
          test -f firestore.rules || { echo "::error::firestore.rules not found"; exit 1; }

      - name: Authenticate to Google Cloud (OIDC/WIF) via service account
        id: auth_sa
        if: ${{ steps.identity.outputs.has_service_account == 'true' }}
        continue-on-error: true
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.identity.outputs.provider }}
          service_account: ${{ steps.identity.outputs.service_account }}
          token_format: access_token
          create_credentials_file: true

      - name: Authenticate to Google Cloud (OIDC/WIF) direct fallback
        id: auth_direct
        if: ${{ steps.identity.outputs.has_service_account != 'true' || steps.auth_sa.outcome == 'failure' }}
        continue-on-error: true
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.identity.outputs.provider }}
          token_format: access_token
          create_credentials_file: true

      - name: Resolve auth strategy result
        id: auth_mode
        run: |
          set -euo pipefail

          has_service_account="${{ steps.identity.outputs.has_service_account }}"
          sa_outcome="${{ steps.auth_sa.outcome }}"
          direct_outcome="${{ steps.auth_direct.outcome }}"
          project_id="${{ steps.project.outputs.project_id }}"
          provider="${{ steps.identity.outputs.provider }}"
          service_account="${{ steps.identity.outputs.service_account }}"

          if [[ "$has_service_account" == "true" && "$sa_outcome" == "success" ]]; then
            echo "mode=service_account_impersonation" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$direct_outcome" == "success" ]]; then
            echo "::warning::Service-account impersonation failed or not configured; using direct WIF fallback."
            echo "mode=direct_wif" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "::error::OIDC/WIF authentication failed in both modes."
          if [[ "$has_service_account" == "true" ]]; then
            echo "::error::Service account path failed for: $service_account"
            echo "::error::Verify this service account exists in project $project_id and has roles/firebaserules.admin."
            echo "::error::Verify Workload Identity binding:"
            echo "::error::gcloud iam service-accounts add-iam-policy-binding \"$service_account\" --project=\"$project_id\" --role=\"roles/iam.workloadIdentityUser\" --member=\"principalSet://iam.googleapis.com/${provider%/providers/*}/attribute.repository/${{ github.repository }}\""
          else
            echo "::warning::GCP_SERVICE_ACCOUNT_EMAIL is empty: trying direct WIF only."
          fi
          echo "::error::For direct WIF fallback, bind principalSet to project role:"
          echo "::error::gcloud projects add-iam-policy-binding \"$project_id\" --member=\"principalSet://iam.googleapis.com/${provider%/providers/*}/attribute.repository/${{ github.repository }}\" --role=\"roles/firebaserules.admin\""
          exit 1

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Verify active identity
        run: |
          set -euo pipefail
          gcloud auth list
          gcloud auth list --filter=status:ACTIVE --format="value(account)"

      - name: Install Firebase CLI
        run: |
          set -euo pipefail
          npm install -g firebase-tools

      - name: Deploy Firestore Rules via Firebase CLI
        id: deploy
        run: |
          set -euo pipefail
          project_id="${{ steps.project.outputs.project_id }}"
          target_sha="${{ github.event.inputs.target_sha }}"
          reason="${{ github.event.inputs.reason }}"

          echo "Project: $project_id"
          echo "SHA: $target_sha"
          echo "Reason: $reason"
          echo "Deploy method: firebase_cli"

          firebase deploy --only firestore:rules --project "$project_id" --non-interactive

          access_token="$(gcloud auth print-access-token)"
          PROJECT_ID="$project_id" ACCESS_TOKEN="$access_token" node - <<'NODE'
          const fs = require('fs');
          const https = require('https');
          const projectId = process.env.PROJECT_ID;
          const accessToken = process.env.ACCESS_TOKEN;
          const outputPath = process.env.GITHUB_OUTPUT;

          if (!projectId || !accessToken || !outputPath) {
            console.error('Missing required environment for release metadata lookup.');
            process.exit(1);
          }
          const releasePath = `/v1/projects/${projectId}/releases/cloud.firestore`;

          function apiGet(path) {
            return new Promise((resolve, reject) => {
              const req = https.request(
                {
                  hostname: 'firebaserules.googleapis.com',
                  path,
                  method: 'GET',
                  headers: {
                    Authorization: `Bearer ${accessToken}`,
                    Accept: 'application/json',
                  },
                },
                (res) => {
                  let raw = '';
                  res.on('data', (chunk) => {
                    raw += chunk;
                  });
                  res.on('end', () => {
                    let parsed = null;
                    if (raw) {
                      try {
                        parsed = JSON.parse(raw);
                      } catch {
                        parsed = { raw };
                      }
                    }
                    if (res.statusCode >= 200 && res.statusCode < 300) {
                      resolve({ status: res.statusCode, body: parsed || {} });
                      return;
                    }
                    reject(
                      new Error(
                        `Firebaserules API GET ${path} failed (${res.statusCode}): ${raw || '<empty>'}`
                      )
                    );
                  });
                }
              );
              req.on('error', reject);
              req.end();
            });
          }

          async function run() {
            const release = await apiGet(releasePath);
            const rulesetName = release?.body?.rulesetName;
            const releaseName = release?.body?.name;
            if (!rulesetName) {
              throw new Error(`Release metadata missing rulesetName: ${JSON.stringify(release)}`);
            }
            if (!releaseName) {
              throw new Error(`Release metadata missing name: ${JSON.stringify(release)}`);
            }

            fs.appendFileSync(outputPath, `ruleset_name=${rulesetName}\n`);
            fs.appendFileSync(outputPath, `release_name=${releaseName}\n`);
            console.log(`Ruleset: ${rulesetName}`);
            console.log(`Release: ${releaseName}`);
          }

          run().catch((error) => {
            console.error(error.message || String(error));
            process.exit(1);
          });
          NODE

      - name: Deployment summary
        if: always()
        run: |
          {
            echo "## Firestore Rules Deployment"
            echo "- status: ${{ job.status }}"
            echo "- auth_mode: oidc_wif_firebase_cli"
            echo "- auth_strategy: \`${{ steps.auth_mode.outputs.mode }}\`"
            echo "- project_id: ${{ steps.project.outputs.project_id }}"
            echo "- target_sha: \`${{ github.event.inputs.target_sha }}\`"
            echo "- actual_sha: \`${{ steps.verify_sha.outputs.actual_sha }}\`"
            echo "- ruleset_name: \`${{ steps.deploy.outputs.ruleset_name }}\`"
            echo "- release_name: \`${{ steps.deploy.outputs.release_name }}\`"
            echo "- reason: ${{ github.event.inputs.reason }}"
            echo "- timestamp_utc: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } >> "$GITHUB_STEP_SUMMARY"

