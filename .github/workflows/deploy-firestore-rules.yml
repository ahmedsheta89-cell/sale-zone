name: Deploy Firestore Rules

on:
  workflow_dispatch:
    inputs:
      target_sha:
        description: "Commit SHA to deploy Firestore rules from"
        required: true
        type: string
      reason:
        description: "Why this rules deployment is requested"
        required: true
        type: string
      auth_mode:
        description: "Auth mode: firebase_token (fast) or oidc_wif"
        required: false
        default: "firebase_token"
        type: string

permissions:
  contents: read
  id-token: write

concurrency:
  group: deploy-firestore-rules
  cancel-in-progress: false

jobs:
  deploy-firestore-rules:
    name: deploy-firestore-rules
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Resolve auth mode
        id: auth_choice
        run: |
          set -euo pipefail
          raw_mode="${{ github.event.inputs.auth_mode || 'firebase_token' }}"
          mode="$(printf '%s' "$raw_mode" | tr '[:upper:]' '[:lower:]' | tr -d '[:space:]')"
          if [[ "$mode" != "firebase_token" && "$mode" != "oidc_wif" ]]; then
            echo "::error::Invalid auth_mode '$raw_mode'. Use firebase_token or oidc_wif."
            exit 1
          fi
          echo "mode=$mode" >> "$GITHUB_OUTPUT"

      - name: Validate required secrets
        run: |
          set -euo pipefail
          mode="${{ steps.auth_choice.outputs.mode }}"
          missing=0

          if [[ "$mode" == "firebase_token" ]]; then
            if [[ -z "${{ secrets.FIREBASE_TOKEN }}" ]]; then
              echo "::error::Missing secret: FIREBASE_TOKEN (required for auth_mode=firebase_token)"
              missing=1
            fi
          else
            if [[ -z "${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}" ]]; then
              echo "::error::Missing secret: GCP_WORKLOAD_IDENTITY_PROVIDER (required for auth_mode=oidc_wif)"
              missing=1
            fi
          fi

          if [[ "$missing" -ne 0 ]]; then
            exit 1
          fi

      - name: Normalize identity secrets
        id: identity
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' }}
        run: |
          set -euo pipefail

          provider_raw="${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}"
          service_account_raw="${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}"

          provider="$(printf '%s' "$provider_raw" | tr -d '[:space:]')"
          service_account="$(printf '%s' "$service_account_raw" | tr -d '[:space:]')"

          if [[ -z "$provider" || "$provider" != projects/*/locations/global/workloadIdentityPools/*/providers/* ]]; then
            echo "::error::Invalid GCP_WORKLOAD_IDENTITY_PROVIDER format."
            echo "::error::Expected: projects/<number>/locations/global/workloadIdentityPools/<pool>/providers/<provider>"
            exit 1
          fi

          has_service_account=false
          if [[ -n "$service_account" ]]; then
            has_service_account=true
          fi

          if [[ "$has_service_account" == "true" && ! "$service_account" =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.iam\.gserviceaccount\.com$ ]]; then
            echo "::error::Invalid GCP_SERVICE_ACCOUNT_EMAIL format."
            echo "::error::Expected: <name>@<project>.iam.gserviceaccount.com"
            exit 1
          fi

          echo "::add-mask::$provider"
          if [[ "$has_service_account" == "true" ]]; then
            echo "::add-mask::$service_account"
          fi

          echo "provider=$provider" >> "$GITHUB_OUTPUT"
          echo "service_account=$service_account" >> "$GITHUB_OUTPUT"
          echo "has_service_account=$has_service_account" >> "$GITHUB_OUTPUT"

      - name: Resolve project id
        id: project
        run: |
          set -euo pipefail
          raw="${{ secrets.FIREBASE_PROJECT_ID }}"
          project_id="$(printf '%s' "${raw:-sale-zone-601f0}" | tr -d '[:space:]')"
          if [[ -z "$project_id" || ! "$project_id" =~ ^[a-z0-9-]+$ ]]; then
            echo "::error::Invalid FIREBASE_PROJECT_ID: '$project_id'"
            exit 1
          fi
          echo "project_id=$project_id" >> "$GITHUB_OUTPUT"

      - name: Checkout target SHA
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.target_sha }}
          fetch-depth: 1

      - name: Verify checkout SHA matches target
        id: verify_sha
        run: |
          set -euo pipefail
          actual_sha="$(git rev-parse HEAD)"
          target_sha="${{ github.event.inputs.target_sha }}"
          if [[ "$actual_sha" != "$target_sha" ]]; then
            echo "::error::Checkout SHA mismatch (actual=$actual_sha, target=$target_sha)"
            exit 1
          fi
          echo "actual_sha=$actual_sha" >> "$GITHUB_OUTPUT"

      - name: Validate firestore.rules exists
        run: |
          set -euo pipefail
          test -f firestore.rules || { echo "::error::firestore.rules not found"; exit 1; }

      - name: Authenticate to Google Cloud (OIDC/WIF) via service account
        id: auth_sa
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' && steps.identity.outputs.has_service_account == 'true' }}
        continue-on-error: true
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.identity.outputs.provider }}
          service_account: ${{ steps.identity.outputs.service_account }}
          token_format: access_token
          create_credentials_file: true

      - name: Authenticate to Google Cloud (OIDC/WIF) direct fallback
        id: auth_direct
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' && (steps.identity.outputs.has_service_account != 'true' || steps.auth_sa.outcome == 'failure') }}
        continue-on-error: true
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ steps.identity.outputs.provider }}
          token_format: access_token
          create_credentials_file: true

      - name: Resolve auth strategy result
        id: auth_mode
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' }}
        run: |
          set -euo pipefail

          has_service_account="${{ steps.identity.outputs.has_service_account }}"
          sa_outcome="${{ steps.auth_sa.outcome }}"
          direct_outcome="${{ steps.auth_direct.outcome }}"
          project_id="${{ steps.project.outputs.project_id }}"
          provider="${{ steps.identity.outputs.provider }}"
          service_account="${{ steps.identity.outputs.service_account }}"

          if [[ "$has_service_account" == "true" && "$sa_outcome" == "success" ]]; then
            echo "mode=service_account_impersonation" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "$direct_outcome" == "success" ]]; then
            echo "::warning::Service-account impersonation failed or not configured; using direct WIF fallback."
            echo "mode=direct_wif" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "::error::OIDC/WIF authentication failed in both modes."
          if [[ "$has_service_account" == "true" ]]; then
            echo "::error::Service account path failed for: $service_account"
            echo "::error::Verify this service account exists in project $project_id and has roles/firebaserules.admin."
            echo "::error::Verify Workload Identity binding:"
            echo "::error::gcloud iam service-accounts add-iam-policy-binding \"$service_account\" --project=\"$project_id\" --role=\"roles/iam.workloadIdentityUser\" --member=\"principalSet://iam.googleapis.com/${provider%/providers/*}/attribute.repository/${{ github.repository }}\""
          else
            echo "::warning::GCP_SERVICE_ACCOUNT_EMAIL is empty: trying direct WIF only."
          fi
          echo "::error::For direct WIF fallback, bind principalSet to project role:"
          echo "::error::gcloud projects add-iam-policy-binding \"$project_id\" --member=\"principalSet://iam.googleapis.com/${provider%/providers/*}/attribute.repository/${{ github.repository }}\" --role=\"roles/firebaserules.admin\""
          exit 1

      - name: Setup gcloud
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' }}
        uses: google-github-actions/setup-gcloud@v2
        with:
          install_components: firebase,alpha

      - name: Verify active identity
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' }}
        run: |
          set -euo pipefail
          gcloud auth list
          gcloud auth list --filter=status:ACTIVE --format="value(account)"

      - name: Setup Node (token mode)
        if: ${{ steps.auth_choice.outputs.mode == 'firebase_token' }}
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Firebase CLI (token mode)
        if: ${{ steps.auth_choice.outputs.mode == 'firebase_token' }}
        run: npm install -g firebase-tools

      - name: Deploy Firestore Rules via gcloud (oidc_wif)
        id: deploy_gcloud
        if: ${{ steps.auth_choice.outputs.mode == 'oidc_wif' }}
        run: |
          set -euo pipefail
          project_id="${{ steps.project.outputs.project_id }}"
          target_sha="${{ github.event.inputs.target_sha }}"
          reason="${{ github.event.inputs.reason }}"

          echo "Project: $project_id"
          echo "SHA: $target_sha"
          echo "Reason: $reason"

          ruleset_name="$(gcloud firebase rulesets create firestore.rules \
            --project="$project_id" \
            --format='value(name)')"

          if gcloud firebase releases describe cloud.firestore --project="$project_id" >/dev/null 2>&1; then
            release_name="$(gcloud firebase releases update cloud.firestore \
              --ruleset="$ruleset_name" \
              --project="$project_id" \
              --format='value(name)')"
          else
            release_name="$(gcloud firebase releases create cloud.firestore \
              --ruleset="$ruleset_name" \
              --project="$project_id" \
              --format='value(name)')"
          fi

          echo "ruleset_name=$ruleset_name" >> "$GITHUB_OUTPUT"
          echo "release_name=$release_name" >> "$GITHUB_OUTPUT"

      - name: Deploy Firestore Rules via Firebase Token (fast mode)
        id: deploy_token
        if: ${{ steps.auth_choice.outputs.mode == 'firebase_token' }}
        env:
          FIREBASE_TOKEN: ${{ secrets.FIREBASE_TOKEN }}
        run: |
          set -euo pipefail
          project_id="${{ steps.project.outputs.project_id }}"
          target_sha="${{ github.event.inputs.target_sha }}"
          reason="${{ github.event.inputs.reason }}"

          echo "Project: $project_id"
          echo "SHA: $target_sha"
          echo "Reason: $reason"
          firebase deploy --only firestore:rules --project "$project_id" --token "$FIREBASE_TOKEN" --non-interactive

          echo "ruleset_name=firebase_cli_token_deploy" >> "$GITHUB_OUTPUT"
          echo "release_name=cloud.firestore" >> "$GITHUB_OUTPUT"

      - name: Deployment summary
        if: always()
        run: |
          {
            echo "## Firestore Rules Deployment"
            echo "- status: ${{ job.status }}"
            echo "- auth_mode: ${{ steps.auth_choice.outputs.mode }}"
            echo "- auth_strategy: \`${{ steps.auth_mode.outputs.mode }}\`"
            echo "- project_id: ${{ steps.project.outputs.project_id }}"
            echo "- target_sha: \`${{ github.event.inputs.target_sha }}\`"
            echo "- actual_sha: \`${{ steps.verify_sha.outputs.actual_sha }}\`"
            echo "- ruleset_name: \`${{ steps.deploy_gcloud.outputs.ruleset_name || steps.deploy_token.outputs.ruleset_name }}\`"
            echo "- release_name: \`${{ steps.deploy_gcloud.outputs.release_name || steps.deploy_token.outputs.release_name }}\`"
            echo "- reason: ${{ github.event.inputs.reason }}"
            echo "- timestamp_utc: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          } >> "$GITHUB_STEP_SUMMARY"
